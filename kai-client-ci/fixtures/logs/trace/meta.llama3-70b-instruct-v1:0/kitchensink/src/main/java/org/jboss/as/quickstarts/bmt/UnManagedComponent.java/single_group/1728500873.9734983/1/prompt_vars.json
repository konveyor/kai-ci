{
    "src_file_name": "src/main/java/org/jboss/as/quickstarts/bmt/UnManagedComponent.java",
    "src_file_language": "java",
    "src_file_contents": "/*\n * JBoss, Home of Professional Open Source\n * Copyright 2015, Red Hat, Inc. and/or its affiliates, and individual\n * contributors by the @authors tag. See the copyright.txt in the\n * distribution for a full listing of individual contributors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jboss.as.quickstarts.bmt;\n\nimport jakarta.enterprise.context.ApplicationScoped;\nimport jakarta.inject.Inject;\nimport jakarta.persistence.EntityManager;\nimport io.quarkus.hibernate.orm.PersistenceUnit;\nimport io.quarkus.logging.Log;\nimport io.quarkus.narayana.jta.QuarkusTransaction;\n\nimport java.util.List;\n\nimport org.jboss.as.quickstarts.bmt.model.KVPair;\n\n/**\n * A class for updating a database table within a JTA transaction. Since the class is only a simple CDI bean the developer is\n * responsible for both controlling the life cycle of the Entity Manager and for transaction demarcation.\n *\n * @author Mike Musgrove\n */\n@ApplicationScoped\npublic class UnManagedComponent {\n    /*\n     * Inject a UserTransaction for manual transaction demarcation (this object is thread safe)\n     */\n    @Inject\n    @PersistenceUnit(\"primary\")\n    private EntityManager entityManager;\n\n    public String updateKeyValueDatabase(String key, String value) {\n        try {\n            Log.info(\"Beginning user-managed transaction\");\n            QuarkusTransaction.begin();\n\n            // make some transactional changes\n            String result = updateKeyValueDatabaseLogic(key, value);\n\n            /*\n             * Note that the default scope of entities managed by the EM is transaction. Thus once the transaction commits the\n             * entity will be detached from the EM. See also the comment in the finally block below.\n             */\n            QuarkusTransaction.commit();\n\n            return result;\n        } catch (Exception e) {\n            QuarkusTransaction.rollback();\n\n            /*\n             * An application cannot handle any of the other exceptions raised by begin and commit so we just catch the generic\n             * exception. The meaning of the other exceptions is:\n             *\n             * NotSupportedException - the thread is already associated with a transaction HeuristicRollbackException - should\n             * not happen since the example is interacting with a single database HeuristicMixedException - should not happen\n             * since the example is interacting with a single database SystemException - the TM raised an unexpected error.\n             * There is no standard way of handling this error (another reason why CMT are preferable to managing them\n             * ourselves)\n             */\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Utility method for updating a key value database.\n     *\n     * @param key if null or zero length then list all pairs\n     * @param value if key exists then associate value with it, otherwise create a new pair\n     * @return the new value of the key value pair or all pairs if key was null (or zero length).\n     */\n    public String updateKeyValueDatabaseLogic(String key, String value) {\n        StringBuilder sb = new StringBuilder();\n\n        if (key == null || key.length() == 0) {\n            // list all key value pairs\n            @SuppressWarnings(\"unchecked\")\n            final List<KVPair> list = entityManager.createQuery(\"select k from KVPair k\").getResultList();\n\n            for (KVPair kvPair : list)\n                sb.append(kvPair.getBmtKey()).append(\"=\").append(kvPair.getBmtValue()).append(',');\n\n        } else {\n            KVPair kvPair;\n\n            if (value == null) {\n                // retrieve the value associated with key\n                kvPair = new KVPair(key, value);\n\n                entityManager.refresh(kvPair);\n            } else {\n                kvPair = entityManager.find(KVPair.class, key);\n\n                if (kvPair == null) {\n                    // insert into the key/value table\n                    kvPair = new KVPair(key, value);\n                    entityManager.persist(kvPair);\n                } else {\n                    // update an existing row in the key/value table\n                    kvPair.setBmtValue(value);\n                    entityManager.persist(kvPair);\n                }\n            }\n\n            sb.append(kvPair.getBmtKey()).append(\"=\").append(kvPair.getBmtValue());\n        }\n\n        return sb.toString();\n    }\n}\n",
    "incidents": [
        {
            "uri": "file:///opt/input/source/src/main/java/org/jboss/as/quickstarts/bmt/UnManagedComponent.java",
            "message": "Replace the `javax.inject` import statement with `jakarta.inject`",
            "code_snip": " 9   * You may obtain a copy of the License at\n10   * http://www.apache.org/licenses/LICENSE-2.0\n11   * Unless required by applicable law or agreed to in writing, software\n12   * distributed under the License is distributed on an \"AS IS\" BASIS,\n13   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n14   * See the License for the specific language governing permissions and\n15   * limitations under the License.\n16   */\n17  package org.jboss.as.quickstarts.bmt;\n18  \n19  import javax.inject.Inject;\n20  import javax.persistence.EntityManager;\n21  import javax.persistence.EntityManagerFactory;\n22  import javax.persistence.PersistenceUnit;\n23  import javax.transaction.RollbackException;\n24  import javax.transaction.Status;\n25  import javax.transaction.UserTransaction;\n26  \n27  import java.util.List;\n28  \n29  /**",
            "line_number": 19,
            "variables": {
                "kind": "Module",
                "renamed": "inject"
            },
            "ruleset_name": "eap8/eap7",
            "ruleset_description": "This ruleset provides analysis of Java EE applications that need to change certain CDI-related method calls.",
            "violation_name": "javax-to-jakarta-import-00001",
            "violation_description": "The package 'javax' has been replaced by 'jakarta'.",
            "solution_str": "Solved example diff:\n```diff\ndiff --git a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\nindex 01916cb..00f1bc4 100644\n--- a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n+++ b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n@@ -16,14 +16,10 @@\n  */\n package org.jboss.as.quickstarts.bmt;\n \n-import javax.ejb.Stateless;\n-import javax.inject.Inject;\n-import javax.persistence.PersistenceContext;\n-import javax.transaction.Status;\n-import javax.transaction.UserTransaction;\n-import javax.ejb.TransactionManagement;\n-import javax.ejb.TransactionManagementType;\n-import javax.persistence.EntityManager;\n+import io.quarkus.logging.Log;\n+import jakarta.enterprise.context.ApplicationScoped;\n+import jakarta.inject.Inject;\n+import jakarta.transaction.Transactional;\n \n /**\n  * A session bean for updating a database table within a JTA transaction\n@@ -36,22 +32,8 @@ import javax.persistence.EntityManager;\n  * for injection into other components (eg the {@linkplain TransactionServlet}): - it becomes eligible for other components to\n  * be injected; - it becomes eligible for Container Managed Transactions (although this example does not use CMT)\n  */\n-@Stateless\n-@TransactionManagement(TransactionManagementType.BEAN)\n-// tell the container not to manage transactions\n+@ApplicationScoped\n public class ManagedComponent {\n-    /**\n-     * Ask the container to inject an Entity Manager (EM). As a consequence the EM will be automatically enlisted into any new\n-     * transactions started by the managed component.\n-     *\n-     */\n-    @PersistenceContext\n-    private EntityManager entityManager;\n-\n-    // Inject a UserTransaction for manual transaction demarcation.\n-    @Inject\n-    private UserTransaction userTransaction;\n-\n     // Inject a utility class for updating JPA entities\n     @Inject\n     private UnManagedComponent helper;\n@@ -67,6 +49,7 @@ public class ManagedComponent {\n      * @return a string representing the keys values pairs if no key is provided, or the key value pair if one is provided, or\n      *         the error if anything went wrong\n      */\n+    @Transactional\n     public String updateKeyValueDatabase(String key, String value) {\n         /*\n          * Since this is a session bean method we are guaranteed to be thread safe so it is OK to use the injected Entity\n@@ -74,30 +57,15 @@ public class ManagedComponent {\n          * method call\n          */\n         try {\n-            userTransaction.begin();\n-\n+            Log.info(&#34;Beginning container-managed transaction&#34;);\n             /*\n              * Since the bean is managed by the container the Entity Manager (EM) and JTA transaction manager (TM) cooperate so\n              * there is no need to tell the EM about the transaction. Compare this with the UnManagedComponent class where the\n              * developer is managing the EM himself and therefore must explicitly tell the EM to join the transaction\n              */\n-            String result = helper.updateKeyValueDatabase(entityManager, key, value);\n-\n-            userTransaction.commit();\n-\n-            return result;\n+            return helper.updateKeyValueDatabaseLogic(key, value);\n         } catch (Exception e) {\n             return e.getMessage();\n-        } finally {\n-            /*\n-             * Clean up\n-             */\n-            try {\n-                if (userTransaction.getStatus() == Status.STATUS_ACTIVE)\n-                    userTransaction.rollback();\n-            } catch (Throwable e) {\n-                // ignore\n-            }\n         }\n     }\n }\n"
        },
        {
            "uri": "file:///opt/input/source/src/main/java/org/jboss/as/quickstarts/bmt/UnManagedComponent.java",
            "message": "Replace the `javax.persistence` import statement with `jakarta.persistence`",
            "code_snip": "10   * http://www.apache.org/licenses/LICENSE-2.0\n11   * Unless required by applicable law or agreed to in writing, software\n12   * distributed under the License is distributed on an \"AS IS\" BASIS,\n13   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n14   * See the License for the specific language governing permissions and\n15   * limitations under the License.\n16   */\n17  package org.jboss.as.quickstarts.bmt;\n18  \n19  import javax.inject.Inject;\n20  import javax.persistence.EntityManager;\n21  import javax.persistence.EntityManagerFactory;\n22  import javax.persistence.PersistenceUnit;\n23  import javax.transaction.RollbackException;\n24  import javax.transaction.Status;\n25  import javax.transaction.UserTransaction;\n26  \n27  import java.util.List;\n28  \n29  /**\n30   * A class for updating a database table within a JTA transaction. Since the class is only a simple CDI bean the developer is",
            "line_number": 20,
            "variables": {
                "kind": "Module",
                "renamed": "persistence"
            },
            "ruleset_name": "eap8/eap7",
            "ruleset_description": "This ruleset provides analysis of Java EE applications that need to change certain CDI-related method calls.",
            "violation_name": "javax-to-jakarta-import-00001",
            "violation_description": "The package 'javax' has been replaced by 'jakarta'.",
            "solution_str": "Solved example diff:\n```diff\ndiff --git a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\nindex 01916cb..00f1bc4 100644\n--- a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n+++ b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n@@ -16,14 +16,10 @@\n  */\n package org.jboss.as.quickstarts.bmt;\n \n-import javax.ejb.Stateless;\n-import javax.inject.Inject;\n-import javax.persistence.PersistenceContext;\n-import javax.transaction.Status;\n-import javax.transaction.UserTransaction;\n-import javax.ejb.TransactionManagement;\n-import javax.ejb.TransactionManagementType;\n-import javax.persistence.EntityManager;\n+import io.quarkus.logging.Log;\n+import jakarta.enterprise.context.ApplicationScoped;\n+import jakarta.inject.Inject;\n+import jakarta.transaction.Transactional;\n \n /**\n  * A session bean for updating a database table within a JTA transaction\n@@ -36,22 +32,8 @@ import javax.persistence.EntityManager;\n  * for injection into other components (eg the {@linkplain TransactionServlet}): - it becomes eligible for other components to\n  * be injected; - it becomes eligible for Container Managed Transactions (although this example does not use CMT)\n  */\n-@Stateless\n-@TransactionManagement(TransactionManagementType.BEAN)\n-// tell the container not to manage transactions\n+@ApplicationScoped\n public class ManagedComponent {\n-    /**\n-     * Ask the container to inject an Entity Manager (EM). As a consequence the EM will be automatically enlisted into any new\n-     * transactions started by the managed component.\n-     *\n-     */\n-    @PersistenceContext\n-    private EntityManager entityManager;\n-\n-    // Inject a UserTransaction for manual transaction demarcation.\n-    @Inject\n-    private UserTransaction userTransaction;\n-\n     // Inject a utility class for updating JPA entities\n     @Inject\n     private UnManagedComponent helper;\n@@ -67,6 +49,7 @@ public class ManagedComponent {\n      * @return a string representing the keys values pairs if no key is provided, or the key value pair if one is provided, or\n      *         the error if anything went wrong\n      */\n+    @Transactional\n     public String updateKeyValueDatabase(String key, String value) {\n         /*\n          * Since this is a session bean method we are guaranteed to be thread safe so it is OK to use the injected Entity\n@@ -74,30 +57,15 @@ public class ManagedComponent {\n          * method call\n          */\n         try {\n-            userTransaction.begin();\n-\n+            Log.info(&#34;Beginning container-managed transaction&#34;);\n             /*\n              * Since the bean is managed by the container the Entity Manager (EM) and JTA transaction manager (TM) cooperate so\n              * there is no need to tell the EM about the transaction. Compare this with the UnManagedComponent class where the\n              * developer is managing the EM himself and therefore must explicitly tell the EM to join the transaction\n              */\n-            String result = helper.updateKeyValueDatabase(entityManager, key, value);\n-\n-            userTransaction.commit();\n-\n-            return result;\n+            return helper.updateKeyValueDatabaseLogic(key, value);\n         } catch (Exception e) {\n             return e.getMessage();\n-        } finally {\n-            /*\n-             * Clean up\n-             */\n-            try {\n-                if (userTransaction.getStatus() == Status.STATUS_ACTIVE)\n-                    userTransaction.rollback();\n-            } catch (Throwable e) {\n-                // ignore\n-            }\n         }\n     }\n }\n"
        },
        {
            "uri": "file:///opt/input/source/src/main/java/org/jboss/as/quickstarts/bmt/UnManagedComponent.java",
            "message": "Replace the `javax.persistence` import statement with `jakarta.persistence`",
            "code_snip": "11   * Unless required by applicable law or agreed to in writing, software\n12   * distributed under the License is distributed on an \"AS IS\" BASIS,\n13   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n14   * See the License for the specific language governing permissions and\n15   * limitations under the License.\n16   */\n17  package org.jboss.as.quickstarts.bmt;\n18  \n19  import javax.inject.Inject;\n20  import javax.persistence.EntityManager;\n21  import javax.persistence.EntityManagerFactory;\n22  import javax.persistence.PersistenceUnit;\n23  import javax.transaction.RollbackException;\n24  import javax.transaction.Status;\n25  import javax.transaction.UserTransaction;\n26  \n27  import java.util.List;\n28  \n29  /**\n30   * A class for updating a database table within a JTA transaction. Since the class is only a simple CDI bean the developer is\n31   * responsible for both controlling the life cycle of the Entity Manager and for transaction demarcation.",
            "line_number": 21,
            "variables": {
                "kind": "Module",
                "renamed": "persistence"
            },
            "ruleset_name": "eap8/eap7",
            "ruleset_description": "This ruleset provides analysis of Java EE applications that need to change certain CDI-related method calls.",
            "violation_name": "javax-to-jakarta-import-00001",
            "violation_description": "The package 'javax' has been replaced by 'jakarta'.",
            "solution_str": "Solved example diff:\n```diff\ndiff --git a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\nindex 01916cb..00f1bc4 100644\n--- a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n+++ b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n@@ -16,14 +16,10 @@\n  */\n package org.jboss.as.quickstarts.bmt;\n \n-import javax.ejb.Stateless;\n-import javax.inject.Inject;\n-import javax.persistence.PersistenceContext;\n-import javax.transaction.Status;\n-import javax.transaction.UserTransaction;\n-import javax.ejb.TransactionManagement;\n-import javax.ejb.TransactionManagementType;\n-import javax.persistence.EntityManager;\n+import io.quarkus.logging.Log;\n+import jakarta.enterprise.context.ApplicationScoped;\n+import jakarta.inject.Inject;\n+import jakarta.transaction.Transactional;\n \n /**\n  * A session bean for updating a database table within a JTA transaction\n@@ -36,22 +32,8 @@ import javax.persistence.EntityManager;\n  * for injection into other components (eg the {@linkplain TransactionServlet}): - it becomes eligible for other components to\n  * be injected; - it becomes eligible for Container Managed Transactions (although this example does not use CMT)\n  */\n-@Stateless\n-@TransactionManagement(TransactionManagementType.BEAN)\n-// tell the container not to manage transactions\n+@ApplicationScoped\n public class ManagedComponent {\n-    /**\n-     * Ask the container to inject an Entity Manager (EM). As a consequence the EM will be automatically enlisted into any new\n-     * transactions started by the managed component.\n-     *\n-     */\n-    @PersistenceContext\n-    private EntityManager entityManager;\n-\n-    // Inject a UserTransaction for manual transaction demarcation.\n-    @Inject\n-    private UserTransaction userTransaction;\n-\n     // Inject a utility class for updating JPA entities\n     @Inject\n     private UnManagedComponent helper;\n@@ -67,6 +49,7 @@ public class ManagedComponent {\n      * @return a string representing the keys values pairs if no key is provided, or the key value pair if one is provided, or\n      *         the error if anything went wrong\n      */\n+    @Transactional\n     public String updateKeyValueDatabase(String key, String value) {\n         /*\n          * Since this is a session bean method we are guaranteed to be thread safe so it is OK to use the injected Entity\n@@ -74,30 +57,15 @@ public class ManagedComponent {\n          * method call\n          */\n         try {\n-            userTransaction.begin();\n-\n+            Log.info(&#34;Beginning container-managed transaction&#34;);\n             /*\n              * Since the bean is managed by the container the Entity Manager (EM) and JTA transaction manager (TM) cooperate so\n              * there is no need to tell the EM about the transaction. Compare this with the UnManagedComponent class where the\n              * developer is managing the EM himself and therefore must explicitly tell the EM to join the transaction\n              */\n-            String result = helper.updateKeyValueDatabase(entityManager, key, value);\n-\n-            userTransaction.commit();\n-\n-            return result;\n+            return helper.updateKeyValueDatabaseLogic(key, value);\n         } catch (Exception e) {\n             return e.getMessage();\n-        } finally {\n-            /*\n-             * Clean up\n-             */\n-            try {\n-                if (userTransaction.getStatus() == Status.STATUS_ACTIVE)\n-                    userTransaction.rollback();\n-            } catch (Throwable e) {\n-                // ignore\n-            }\n         }\n     }\n }\n"
        },
        {
            "uri": "file:///opt/input/source/src/main/java/org/jboss/as/quickstarts/bmt/UnManagedComponent.java",
            "message": "Replace the `javax.persistence` import statement with `jakarta.persistence`",
            "code_snip": "12   * distributed under the License is distributed on an \"AS IS\" BASIS,\n13   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n14   * See the License for the specific language governing permissions and\n15   * limitations under the License.\n16   */\n17  package org.jboss.as.quickstarts.bmt;\n18  \n19  import javax.inject.Inject;\n20  import javax.persistence.EntityManager;\n21  import javax.persistence.EntityManagerFactory;\n22  import javax.persistence.PersistenceUnit;\n23  import javax.transaction.RollbackException;\n24  import javax.transaction.Status;\n25  import javax.transaction.UserTransaction;\n26  \n27  import java.util.List;\n28  \n29  /**\n30   * A class for updating a database table within a JTA transaction. Since the class is only a simple CDI bean the developer is\n31   * responsible for both controlling the life cycle of the Entity Manager and for transaction demarcation.\n32   *",
            "line_number": 22,
            "variables": {
                "kind": "Module",
                "renamed": "persistence"
            },
            "ruleset_name": "eap8/eap7",
            "ruleset_description": "This ruleset provides analysis of Java EE applications that need to change certain CDI-related method calls.",
            "violation_name": "javax-to-jakarta-import-00001",
            "violation_description": "The package 'javax' has been replaced by 'jakarta'.",
            "solution_str": "Solved example diff:\n```diff\ndiff --git a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\nindex 01916cb..00f1bc4 100644\n--- a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n+++ b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n@@ -16,14 +16,10 @@\n  */\n package org.jboss.as.quickstarts.bmt;\n \n-import javax.ejb.Stateless;\n-import javax.inject.Inject;\n-import javax.persistence.PersistenceContext;\n-import javax.transaction.Status;\n-import javax.transaction.UserTransaction;\n-import javax.ejb.TransactionManagement;\n-import javax.ejb.TransactionManagementType;\n-import javax.persistence.EntityManager;\n+import io.quarkus.logging.Log;\n+import jakarta.enterprise.context.ApplicationScoped;\n+import jakarta.inject.Inject;\n+import jakarta.transaction.Transactional;\n \n /**\n  * A session bean for updating a database table within a JTA transaction\n@@ -36,22 +32,8 @@ import javax.persistence.EntityManager;\n  * for injection into other components (eg the {@linkplain TransactionServlet}): - it becomes eligible for other components to\n  * be injected; - it becomes eligible for Container Managed Transactions (although this example does not use CMT)\n  */\n-@Stateless\n-@TransactionManagement(TransactionManagementType.BEAN)\n-// tell the container not to manage transactions\n+@ApplicationScoped\n public class ManagedComponent {\n-    /**\n-     * Ask the container to inject an Entity Manager (EM). As a consequence the EM will be automatically enlisted into any new\n-     * transactions started by the managed component.\n-     *\n-     */\n-    @PersistenceContext\n-    private EntityManager entityManager;\n-\n-    // Inject a UserTransaction for manual transaction demarcation.\n-    @Inject\n-    private UserTransaction userTransaction;\n-\n     // Inject a utility class for updating JPA entities\n     @Inject\n     private UnManagedComponent helper;\n@@ -67,6 +49,7 @@ public class ManagedComponent {\n      * @return a string representing the keys values pairs if no key is provided, or the key value pair if one is provided, or\n      *         the error if anything went wrong\n      */\n+    @Transactional\n     public String updateKeyValueDatabase(String key, String value) {\n         /*\n          * Since this is a session bean method we are guaranteed to be thread safe so it is OK to use the injected Entity\n@@ -74,30 +57,15 @@ public class ManagedComponent {\n          * method call\n          */\n         try {\n-            userTransaction.begin();\n-\n+            Log.info(&#34;Beginning container-managed transaction&#34;);\n             /*\n              * Since the bean is managed by the container the Entity Manager (EM) and JTA transaction manager (TM) cooperate so\n              * there is no need to tell the EM about the transaction. Compare this with the UnManagedComponent class where the\n              * developer is managing the EM himself and therefore must explicitly tell the EM to join the transaction\n              */\n-            String result = helper.updateKeyValueDatabase(entityManager, key, value);\n-\n-            userTransaction.commit();\n-\n-            return result;\n+            return helper.updateKeyValueDatabaseLogic(key, value);\n         } catch (Exception e) {\n             return e.getMessage();\n-        } finally {\n-            /*\n-             * Clean up\n-             */\n-            try {\n-                if (userTransaction.getStatus() == Status.STATUS_ACTIVE)\n-                    userTransaction.rollback();\n-            } catch (Throwable e) {\n-                // ignore\n-            }\n         }\n     }\n }\n"
        },
        {
            "uri": "file:///opt/input/source/src/main/java/org/jboss/as/quickstarts/bmt/UnManagedComponent.java",
            "message": "Replace the `javax.transaction` import statement with `jakarta.transaction`",
            "code_snip": "13   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n14   * See the License for the specific language governing permissions and\n15   * limitations under the License.\n16   */\n17  package org.jboss.as.quickstarts.bmt;\n18  \n19  import javax.inject.Inject;\n20  import javax.persistence.EntityManager;\n21  import javax.persistence.EntityManagerFactory;\n22  import javax.persistence.PersistenceUnit;\n23  import javax.transaction.RollbackException;\n24  import javax.transaction.Status;\n25  import javax.transaction.UserTransaction;\n26  \n27  import java.util.List;\n28  \n29  /**\n30   * A class for updating a database table within a JTA transaction. Since the class is only a simple CDI bean the developer is\n31   * responsible for both controlling the life cycle of the Entity Manager and for transaction demarcation.\n32   *\n33   * @author Mike Musgrove",
            "line_number": 23,
            "variables": {
                "kind": "Module",
                "renamed": "transaction"
            },
            "ruleset_name": "eap8/eap7",
            "ruleset_description": "This ruleset provides analysis of Java EE applications that need to change certain CDI-related method calls.",
            "violation_name": "javax-to-jakarta-import-00001",
            "violation_description": "The package 'javax' has been replaced by 'jakarta'.",
            "solution_str": "Solved example diff:\n```diff\ndiff --git a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\nindex 01916cb..00f1bc4 100644\n--- a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n+++ b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n@@ -16,14 +16,10 @@\n  */\n package org.jboss.as.quickstarts.bmt;\n \n-import javax.ejb.Stateless;\n-import javax.inject.Inject;\n-import javax.persistence.PersistenceContext;\n-import javax.transaction.Status;\n-import javax.transaction.UserTransaction;\n-import javax.ejb.TransactionManagement;\n-import javax.ejb.TransactionManagementType;\n-import javax.persistence.EntityManager;\n+import io.quarkus.logging.Log;\n+import jakarta.enterprise.context.ApplicationScoped;\n+import jakarta.inject.Inject;\n+import jakarta.transaction.Transactional;\n \n /**\n  * A session bean for updating a database table within a JTA transaction\n@@ -36,22 +32,8 @@ import javax.persistence.EntityManager;\n  * for injection into other components (eg the {@linkplain TransactionServlet}): - it becomes eligible for other components to\n  * be injected; - it becomes eligible for Container Managed Transactions (although this example does not use CMT)\n  */\n-@Stateless\n-@TransactionManagement(TransactionManagementType.BEAN)\n-// tell the container not to manage transactions\n+@ApplicationScoped\n public class ManagedComponent {\n-    /**\n-     * Ask the container to inject an Entity Manager (EM). As a consequence the EM will be automatically enlisted into any new\n-     * transactions started by the managed component.\n-     *\n-     */\n-    @PersistenceContext\n-    private EntityManager entityManager;\n-\n-    // Inject a UserTransaction for manual transaction demarcation.\n-    @Inject\n-    private UserTransaction userTransaction;\n-\n     // Inject a utility class for updating JPA entities\n     @Inject\n     private UnManagedComponent helper;\n@@ -67,6 +49,7 @@ public class ManagedComponent {\n      * @return a string representing the keys values pairs if no key is provided, or the key value pair if one is provided, or\n      *         the error if anything went wrong\n      */\n+    @Transactional\n     public String updateKeyValueDatabase(String key, String value) {\n         /*\n          * Since this is a session bean method we are guaranteed to be thread safe so it is OK to use the injected Entity\n@@ -74,30 +57,15 @@ public class ManagedComponent {\n          * method call\n          */\n         try {\n-            userTransaction.begin();\n-\n+            Log.info(&#34;Beginning container-managed transaction&#34;);\n             /*\n              * Since the bean is managed by the container the Entity Manager (EM) and JTA transaction manager (TM) cooperate so\n              * there is no need to tell the EM about the transaction. Compare this with the UnManagedComponent class where the\n              * developer is managing the EM himself and therefore must explicitly tell the EM to join the transaction\n              */\n-            String result = helper.updateKeyValueDatabase(entityManager, key, value);\n-\n-            userTransaction.commit();\n-\n-            return result;\n+            return helper.updateKeyValueDatabaseLogic(key, value);\n         } catch (Exception e) {\n             return e.getMessage();\n-        } finally {\n-            /*\n-             * Clean up\n-             */\n-            try {\n-                if (userTransaction.getStatus() == Status.STATUS_ACTIVE)\n-                    userTransaction.rollback();\n-            } catch (Throwable e) {\n-                // ignore\n-            }\n         }\n     }\n }\n"
        },
        {
            "uri": "file:///opt/input/source/src/main/java/org/jboss/as/quickstarts/bmt/UnManagedComponent.java",
            "message": "Replace the `javax.transaction` import statement with `jakarta.transaction`",
            "code_snip": "14   * See the License for the specific language governing permissions and\n15   * limitations under the License.\n16   */\n17  package org.jboss.as.quickstarts.bmt;\n18  \n19  import javax.inject.Inject;\n20  import javax.persistence.EntityManager;\n21  import javax.persistence.EntityManagerFactory;\n22  import javax.persistence.PersistenceUnit;\n23  import javax.transaction.RollbackException;\n24  import javax.transaction.Status;\n25  import javax.transaction.UserTransaction;\n26  \n27  import java.util.List;\n28  \n29  /**\n30   * A class for updating a database table within a JTA transaction. Since the class is only a simple CDI bean the developer is\n31   * responsible for both controlling the life cycle of the Entity Manager and for transaction demarcation.\n32   *\n33   * @author Mike Musgrove\n34   */",
            "line_number": 24,
            "variables": {
                "kind": "Module",
                "renamed": "transaction"
            },
            "ruleset_name": "eap8/eap7",
            "ruleset_description": "This ruleset provides analysis of Java EE applications that need to change certain CDI-related method calls.",
            "violation_name": "javax-to-jakarta-import-00001",
            "violation_description": "The package 'javax' has been replaced by 'jakarta'.",
            "solution_str": "Solved example diff:\n```diff\ndiff --git a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\nindex 01916cb..00f1bc4 100644\n--- a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n+++ b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n@@ -16,14 +16,10 @@\n  */\n package org.jboss.as.quickstarts.bmt;\n \n-import javax.ejb.Stateless;\n-import javax.inject.Inject;\n-import javax.persistence.PersistenceContext;\n-import javax.transaction.Status;\n-import javax.transaction.UserTransaction;\n-import javax.ejb.TransactionManagement;\n-import javax.ejb.TransactionManagementType;\n-import javax.persistence.EntityManager;\n+import io.quarkus.logging.Log;\n+import jakarta.enterprise.context.ApplicationScoped;\n+import jakarta.inject.Inject;\n+import jakarta.transaction.Transactional;\n \n /**\n  * A session bean for updating a database table within a JTA transaction\n@@ -36,22 +32,8 @@ import javax.persistence.EntityManager;\n  * for injection into other components (eg the {@linkplain TransactionServlet}): - it becomes eligible for other components to\n  * be injected; - it becomes eligible for Container Managed Transactions (although this example does not use CMT)\n  */\n-@Stateless\n-@TransactionManagement(TransactionManagementType.BEAN)\n-// tell the container not to manage transactions\n+@ApplicationScoped\n public class ManagedComponent {\n-    /**\n-     * Ask the container to inject an Entity Manager (EM). As a consequence the EM will be automatically enlisted into any new\n-     * transactions started by the managed component.\n-     *\n-     */\n-    @PersistenceContext\n-    private EntityManager entityManager;\n-\n-    // Inject a UserTransaction for manual transaction demarcation.\n-    @Inject\n-    private UserTransaction userTransaction;\n-\n     // Inject a utility class for updating JPA entities\n     @Inject\n     private UnManagedComponent helper;\n@@ -67,6 +49,7 @@ public class ManagedComponent {\n      * @return a string representing the keys values pairs if no key is provided, or the key value pair if one is provided, or\n      *         the error if anything went wrong\n      */\n+    @Transactional\n     public String updateKeyValueDatabase(String key, String value) {\n         /*\n          * Since this is a session bean method we are guaranteed to be thread safe so it is OK to use the injected Entity\n@@ -74,30 +57,15 @@ public class ManagedComponent {\n          * method call\n          */\n         try {\n-            userTransaction.begin();\n-\n+            Log.info(&#34;Beginning container-managed transaction&#34;);\n             /*\n              * Since the bean is managed by the container the Entity Manager (EM) and JTA transaction manager (TM) cooperate so\n              * there is no need to tell the EM about the transaction. Compare this with the UnManagedComponent class where the\n              * developer is managing the EM himself and therefore must explicitly tell the EM to join the transaction\n              */\n-            String result = helper.updateKeyValueDatabase(entityManager, key, value);\n-\n-            userTransaction.commit();\n-\n-            return result;\n+            return helper.updateKeyValueDatabaseLogic(key, value);\n         } catch (Exception e) {\n             return e.getMessage();\n-        } finally {\n-            /*\n-             * Clean up\n-             */\n-            try {\n-                if (userTransaction.getStatus() == Status.STATUS_ACTIVE)\n-                    userTransaction.rollback();\n-            } catch (Throwable e) {\n-                // ignore\n-            }\n         }\n     }\n }\n"
        },
        {
            "uri": "file:///opt/input/source/src/main/java/org/jboss/as/quickstarts/bmt/UnManagedComponent.java",
            "message": "Replace the `javax.transaction` import statement with `jakarta.transaction`",
            "code_snip": "15   * limitations under the License.\n16   */\n17  package org.jboss.as.quickstarts.bmt;\n18  \n19  import javax.inject.Inject;\n20  import javax.persistence.EntityManager;\n21  import javax.persistence.EntityManagerFactory;\n22  import javax.persistence.PersistenceUnit;\n23  import javax.transaction.RollbackException;\n24  import javax.transaction.Status;\n25  import javax.transaction.UserTransaction;\n26  \n27  import java.util.List;\n28  \n29  /**\n30   * A class for updating a database table within a JTA transaction. Since the class is only a simple CDI bean the developer is\n31   * responsible for both controlling the life cycle of the Entity Manager and for transaction demarcation.\n32   *\n33   * @author Mike Musgrove\n34   */\n35  public class UnManagedComponent {",
            "line_number": 25,
            "variables": {
                "kind": "Module",
                "renamed": "transaction"
            },
            "ruleset_name": "eap8/eap7",
            "ruleset_description": "This ruleset provides analysis of Java EE applications that need to change certain CDI-related method calls.",
            "violation_name": "javax-to-jakarta-import-00001",
            "violation_description": "The package 'javax' has been replaced by 'jakarta'.",
            "solution_str": "Solved example diff:\n```diff\ndiff --git a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\nindex 01916cb..00f1bc4 100644\n--- a/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n+++ b/src/main/java/org/jboss/as/quickstarts/bmt/ManagedComponent.java\n@@ -16,14 +16,10 @@\n  */\n package org.jboss.as.quickstarts.bmt;\n \n-import javax.ejb.Stateless;\n-import javax.inject.Inject;\n-import javax.persistence.PersistenceContext;\n-import javax.transaction.Status;\n-import javax.transaction.UserTransaction;\n-import javax.ejb.TransactionManagement;\n-import javax.ejb.TransactionManagementType;\n-import javax.persistence.EntityManager;\n+import io.quarkus.logging.Log;\n+import jakarta.enterprise.context.ApplicationScoped;\n+import jakarta.inject.Inject;\n+import jakarta.transaction.Transactional;\n \n /**\n  * A session bean for updating a database table within a JTA transaction\n@@ -36,22 +32,8 @@ import javax.persistence.EntityManager;\n  * for injection into other components (eg the {@linkplain TransactionServlet}): - it becomes eligible for other components to\n  * be injected; - it becomes eligible for Container Managed Transactions (although this example does not use CMT)\n  */\n-@Stateless\n-@TransactionManagement(TransactionManagementType.BEAN)\n-// tell the container not to manage transactions\n+@ApplicationScoped\n public class ManagedComponent {\n-    /**\n-     * Ask the container to inject an Entity Manager (EM). As a consequence the EM will be automatically enlisted into any new\n-     * transactions started by the managed component.\n-     *\n-     */\n-    @PersistenceContext\n-    private EntityManager entityManager;\n-\n-    // Inject a UserTransaction for manual transaction demarcation.\n-    @Inject\n-    private UserTransaction userTransaction;\n-\n     // Inject a utility class for updating JPA entities\n     @Inject\n     private UnManagedComponent helper;\n@@ -67,6 +49,7 @@ public class ManagedComponent {\n      * @return a string representing the keys values pairs if no key is provided, or the key value pair if one is provided, or\n      *         the error if anything went wrong\n      */\n+    @Transactional\n     public String updateKeyValueDatabase(String key, String value) {\n         /*\n          * Since this is a session bean method we are guaranteed to be thread safe so it is OK to use the injected Entity\n@@ -74,30 +57,15 @@ public class ManagedComponent {\n          * method call\n          */\n         try {\n-            userTransaction.begin();\n-\n+            Log.info(&#34;Beginning container-managed transaction&#34;);\n             /*\n              * Since the bean is managed by the container the Entity Manager (EM) and JTA transaction manager (TM) cooperate so\n              * there is no need to tell the EM about the transaction. Compare this with the UnManagedComponent class where the\n              * developer is managing the EM himself and therefore must explicitly tell the EM to join the transaction\n              */\n-            String result = helper.updateKeyValueDatabase(entityManager, key, value);\n-\n-            userTransaction.commit();\n-\n-            return result;\n+            return helper.updateKeyValueDatabaseLogic(key, value);\n         } catch (Exception e) {\n             return e.getMessage();\n-        } finally {\n-            /*\n-             * Clean up\n-             */\n-            try {\n-                if (userTransaction.getStatus() == Status.STATUS_ACTIVE)\n-                    userTransaction.rollback();\n-            } catch (Throwable e) {\n-                // ignore\n-            }\n         }\n     }\n }\n"
        }
    ]
}